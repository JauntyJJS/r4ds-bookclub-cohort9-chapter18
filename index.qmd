---
title: |
  Chapter 18: Missing Values
subtitle: |
  For the R For Data Science 2nd Edition Book Club Cohort 9  [`r fontawesome::fa(name = "youtube")`](https://www.youtube.com/playlist?list=PL3x6DOfs2NGjVMs1NtbWu4s_ZgGhGKnrN)
author: Jeremy Selva [`r fontawesome::fa(name = "linkedin")`](https://www.linkedin.com/in/jeremy-selva-085b9112a/) <br> @JauntyJJS [`r fontawesome::fa(name = "github")`](https://github.com/JauntyJJS) [`r fontawesome::fa(name = "twitter")`](https://twitter.com/JauntyJJS) <br> https://jeremy-selva.netlify.app [`r fontawesome::fa(name = "link")`](https://jeremy-selva.netlify.app/)
knitr:
  opts_chunk:
    echo: true
    warning: false
    message: false
    dpi: 320
    out.width: "80%"
    fig.width: 6
    fig.asp: 0.618
    fig.retina: 2
    fig.align: "center"
    fig.show: "hold"
format:
  revealjs:
    theme: [dark, custom.scss]
    embed-resources: false
    controls: true
    slide-number: true
    scrollable: true
    mouse-wheel: true
    preview-links: auto
---

```{r setup, include=FALSE}
library(fontawesome)
library(palmerpenguins)
library(nycflights13)
library(tidyverse)
library(reactable)
library(reactablefmtr)
```

## Introduction

:::: {.columns}

We encountered missing values in previous chapters.

::: {.column width="50%"}

```{r}
#| echo: true
#| warning: true
#| fig-height: 8
#| fig-alt: "A scatterplot of penguin's body mass in grams vs flipper length in mm."

ggplot2::ggplot(
  data = penguins,
  mapping = ggplot2::aes(
      x = .data[["flipper_length_mm"]], 
      y = .data[["body_mass_g"]]
      )
) + 
ggplot2::geom_point()
```

:::

::: {.column width="50%"}

```{r}
#| echo: true

penguins |> 
  dplyr::filter(
    is.na(flipper_length_mm) | is.na(body_mass_g)
  ) |> 
  reactable::reactable(
    theme = reactablefmtr::dark()
  )
```

:::

::::

## Introduction

We encountered missing values in previous chapters.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

flights |> 
  dplyr::group_by(.data[["month"]]) |> 
  summarize(
    avg_delay = mean(.data[["dep_delay"]])
  ) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

flights |> 
  dplyr::group_by(.data[["month"]]) |> 
  summarize(
    avg_delay = mean(.data[["dep_delay"]], 
                     na.rm = TRUE)
  ) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::::

## Introduction

We encountered missing values in previous chapters.

```{r}
#| echo: true

NA > 5

10 == NA

NA == NA

```

We learn more of the details in this chapter, covering additional tools (besides `is.na` and `na.rm` argument) for working with missing values

*  Explicit missing values
*  Implicit missing values
*  Empty groups

## Explicit missing values 

:::: {.columns}

When data is entered by hand, missing values sometimes indicate that the value in the previous row has been repeated (or carried forward). We can fill down in these missing values with [`tidyr::fill()`](https://tidyr.tidyverse.org/reference/fill.html)

::: {.column width="50%"}

```{r}
#| echo: true

treatment <- tibble::tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)

print(treatment)
```

:::

::: {.column width="50%"}

```{r}
#| echo: true

treatment |>
  tidyr::fill(
    dplyr::everything(),
    .direction = "down"
)

```

:::

::::

## Explicit missing values 

Missing values may need to be represented with some fixed and known value, most commonly 0. You can use [`dplyr::coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.html) to replace them

```{r}
#| echo: true

x <- c(1, 4, 5, 7, NA)
dplyr::coalesce(x, 0)

y <- c(1, 2, NA, NA, 5)
z <- c(NA, NA, 3, 4, 5)
dplyr::coalesce(y, z)

```

## Explicit missing values 

If we need to replace na for multiple columns, [`tidyr::replace_na`](https://tidyr.tidyverse.org/reference/replace_na.html) is more useful.

```{r}
#| echo: true

df <- tibble::tibble(x = c(1, 2, NA), y = c("a", NA, "b"))

df

df |> tidyr::replace_na(list(x = 0, y = "unknown"))

```

## Explicit missing values 

On the other hand, some concrete value actually represents a missing value. This typically arises in data generated by older software that doesn’t have a proper way to represent missing values, so it must instead use some special value like 99 or -999.

If possible, handle this when reading in the data, for example, by using the `na` argument to [`readr::read_csv()`](https://readr.tidyverse.org/reference/read_delim.html), e.g., `read_csv(path, na = "99")`

If you discover the problem later, or your data source doesn’t provide a way to handle it on read, you can use [`dplyr::na_if()`](https://dplyr.tidyverse.org/reference/na_if.html):

```{r}
#| echo: true

x <- c(1, 4, 5, 7, -99)
na_if(x, -99)

```

## Explicit missing values 

R has one special type of missing value called `NaN` (pronounced “nan”), or **n**ot **a** **n**umber. NaN occurs when a mathematical operation that has an indeterminate result:

```{r}
#| echo: true

0 / 0

0 * Inf

Inf - Inf

sqrt(-1)
```

## Explicit missing values 

`NaN` generally behaves just like `NA`.

```{r}
#| echo: true

x <- c(NA, NaN)

x * 10

x == 1

is.na(x)

```

In the rare case you need to distinguish an `NA` from a `NaN`, you can use `is.nan(x)`.

```{r}

is.nan(x)

```

## Implicit missing values

Consider a simple dataset that records the price of some stock each quarter:

```{r}
#| echo: true

stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)

```

This dataset has two missing observations:

-  The price in the fourth quarter of 2020 is explicitly missing, because its value is NA.

-  The price for the first quarter of 2021 is implicitly missing, because it simply does not appear in the dataset.

## Implicit missing values

If there is a need to make implicit missing values explicit, we can pivot the data using [`tidyr::pivot_wider`](https://tidyr.tidyverse.org/reference/pivot_wider.html).

```{r}
#| echo: true

wide_stocks <-  stocks |>
  tidyr::pivot_wider(
    names_from = "qtr", 
    values_from = "price"
  )

wide_stocks
```

## Implicit missing values

:::: {.columns}

By default, making data longer using [`tidyr::pivot_longer`](https://tidyr.tidyverse.org/reference/pivot_longer.html) preserves explicit missing values. We can drop them (make them implicit) by setting `values_drop_na = TRUE`.

::: {.column width="50%"}

```{r}
#| echo: true

wide_stocks |>
  tidyr::pivot_longer(
    cols = -c("year"),
    names_to = "qtr", 
    values_to = "price"
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

wide_stocks |>
  tidyr::pivot_longer(
    cols = -c("year"),
    names_to = "qtr", 
    values_to = "price",
    values_drop_na = TRUE
  )

```

:::

::::

## Implicit missing values

[`tidyr::complete()`](https://tidyr.tidyverse.org/reference/complete.html) turns implicit missing values into explicit missing values based on combination values from its input columns.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

stocks |>
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 7
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

stocks |>
  tidyr::complete(
    .data[["year"]], 
    .data[["qtr"]]) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 4
  )

```

:::

::::

## Implicit missing values

Sometimes the individual variables are themselves incomplete and they is a need to provide your own data. For example, if we know that the stocks dataset is supposed to run from 2019 to 2021, we could explicitly supply those values for year.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

stocks |>
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 7
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

stocks |>
  tidyr::complete(
    `year` = 2019:2021, 
    .data[["qtr"]]) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 4
  )

```

:::

::::

## Implicit missing values

Another way to reveal implicitly missing observations is by using [`dplyr::anti_join`](https://dplyr.tidyverse.org/reference/filter-joins.html). Here, four of the destinations do not have any [airport](https://nycflights13.tidyverse.org/reference/airports.html) metadata information.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

# Get unique destination and rename to faa

dest_flights <- flights |> 
  dplyr::distinct(faa = .data[["dest"]])

dest_flights |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

dest_flights |> 
  dplyr::anti_join(
    y = airports,
    by = dplyr::join_by("faa")
 ) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::::

## Implicit missing values

Here, 722 planes do not have any [planes](https://nycflights13.tidyverse.org/reference/planes.html) metadata information.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

# Get unique tail numbers

tailnum_flights <- flights |> 
  dplyr::distinct(.data[["tailnum"]])

tailnum_flights |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

tailnum_flights |> 
  dplyr::anti_join(
    y = planes,
    by = dplyr::join_by("tailnum")
 ) |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    defaultPageSize = 5
  )

```

:::

::::

## Exercises

Can you find any relationship between the carrier and the rows that appear to be missing from `planes` ?

```{r}
#| echo: true

tailnum_carrier_flights <- flights |> 
  dplyr::distinct(.data[["tailnum"]], .data[["carrier"]]) |> 
  dplyr::arrange(.data[["carrier"]]) |> 
  dplyr::left_join(
    airlines,
    by = dplyr::join_by("carrier")
  )

tailnum_carrier_flights |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    filterable = TRUE,
    defaultPageSize = 5
  )

```

## Exercises

Can you find any relationship between the carrier and the rows that appear to be missing from `planes` ?

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

missing_tailnum_carrier_flights <- tailnum_carrier_flights |> 
  dplyr::anti_join(
    y = planes,
    by = dplyr::join_by("tailnum")
 ) 

missing_tailnum_carrier_flights[["carrier"]] |> 
  table()

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

missing_tailnum_carrier_flights |> 
  reactable::reactable(
    theme = reactablefmtr::dark(),
    filterable = TRUE,
    defaultPageSize = 5
  )

```

:::

::::

##  Factors and empty groups

A final type of missingness is the empty group, a group that doesn’t contain any observations, which can arise when working with factors.

Here is a dataset that contains some health information about people.

```{r}
#| echo: true

health <- tibble(
  name   = c("Ikaia", "Oletta", "Leriah", "Dashay", "Tresaun"),
  smoker = factor(c("no", "no", "no", "no", "no"), levels = c("yes", "no")),
  age    = c(34, 88, 75, 47, 56),
)

```

##  Factors and empty groups

We want to count the number of smokers and non-smokers with [`dplyr::count()`](https://dplyr.tidyverse.org/reference/count.html) but it only gives us the amount of smokers because  the group of smokers is empty

```{r}
#| echo: true

health |> dplyr::count(smoker)

```

We can request count() to keep all the groups, even those not seen in the data by using  `.drop = FALSE`:

```{r}
#| echo: true

health |> dplyr::count(smoker,
                       .drop = FALSE)

```

##  Factors and empty groups

The same principle applies to `ggplot2’s` discrete axes, which will also drop levels that don’t have any values. You can force them to display by supplying `drop = FALSE` to the appropriate discrete axis

:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

ggplot2::ggplot(
  data = health, 
  mapping = ggplot2::aes(
    x = .data[["smoker"]])
  ) +
  ggplot2::geom_bar() +
  ggplot2::scale_x_discrete()

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

ggplot2::ggplot(
  data = health, 
  mapping = ggplot2::aes(
    x = .data[["smoker"]])
  ) +
  ggplot2::geom_bar() +
  ggplot2::scale_x_discrete(drop = FALSE)

```

:::

::::

##  Factors and empty groups

The same problem comes up more generally with [`dplyr::group_by()`](https://dplyr.tidyverse.org/reference/group_by.html). And again you can use `.drop = FALSE` to preserve all factor levels:


:::: {.columns}

::: {.column width="50%"}

```{r}
#| echo: true

health |> 
  dplyr::group_by(
    .data[["smoker"]]
  ) |> 
  dplyr::summarize(
    n = dplyr::n(),
    mean_age = mean(.data[["age"]]),
    min_age = min(.data[["age"]]),
    max_age = max(.data[["age"]]),
    sd_age = sd(.data[["age"]])
  )

```

:::

::: {.column width="50%"}

```{r}
#| echo: true

health |> 
  dplyr::group_by(
    .data[["smoker"]], 
    .drop = FALSE) |> 
  dplyr::summarize(
    n = dplyr::n(),
    mean_age = mean(.data[["age"]]),
    min_age = min(.data[["age"]]),
    max_age = max(.data[["age"]]),
    sd_age = sd(.data[["age"]])
  )

```

:::

We get some interesting results here because when summarizing an empty group, the summary functions are applied to zero-length vectors
::::

##  Factors and empty groups

Here we see `mean({zero_vec})` returning `NaN` because 

`mean({zero_vec}) =` `sum({zero_vec})/length({zero_vec})` 

which is 0/0. 

`max()` and `min()` return `-Inf` and `Inf` for empty vectors.


```{r}
#| echo: true

health |> 
  dplyr::group_by(
    .data[["smoker"]], 
    .drop = FALSE) |> 
  dplyr::summarize(
    n = dplyr::n(),
    mean_age = mean(.data[["age"]]),
    min_age = min(.data[["age"]]),
    max_age = max(.data[["age"]]),
    sd_age = sd(.data[["age"]])
  )

```

##  Factors and empty groups

Instead of `.drop = FALSE`, we can use [`tidyr::complete()`](https://tidyr.tidyverse.org/reference/complete.html)  to the implicit missing values explicit. The main drawback of this approach is that you get an `NA` for the count, even though you know that it should be zero.


```{r}
#| echo: true

health |> 
  dplyr::group_by(
    .data[["smoker"]]
  ) |> 
  dplyr::summarize(
    n = dplyr::n(),
    mean_age = mean(.data[["age"]]),
    min_age = min(.data[["age"]]),
    max_age = max(.data[["age"]]),
    sd_age = sd(.data[["age"]])
  ) |> 
  tidyr::complete(.data[["smoker"]])

```
